//
// Generated file, do not edit! Created by opp_msgc 4.1 from applications/denacastapp/VideoMessage.msg.
//

#ifndef _VIDEOMESSAGE_M_H_
#define _VIDEOMESSAGE_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0401
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include <BufferMap.h>
#include <TransportAddress.h>
#include "VideoFrame.h"
#include "Chunk.h"
   



static const int CHUNKNUMBER_L = 16;
static const int FRAMENUMBER_L = 16;
static const int FRAMETYPE_L = 2;
static const int FRAMELENGTH_L = 16;
static const int TOTALBANDWIDTH_L = 32;
static const int VIDEOCOMMAND_L = 3;

#define VIDEOMESSAGE_L(msg) (VIDEOCOMMAND_L + CHUNKNUMBER_L + 2*TRANSPORTADDRESS_L)
#define BUFFERMAPMESSAGE_L(msg) (TRANSPORTADDRESS_L + TOTALBANDWIDTH_L)
// }}



/**
 * Enum generated from <tt>applications/denacastapp/VideoMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum VideoCommand
 * {
 *     CAMERA_MSG=0;	
 *     PLAYER_MSG=1;	
 *     CHUNK_REQ=2;	
 *     CHUNK_RSP=3;	
 *     NEIGHBOR_LEAVE=4;
 *     LEAVING=5;
 * }
 * </pre>
 */
enum VideoCommand {
    CAMERA_MSG = 0,
    PLAYER_MSG = 1,
    CHUNK_REQ = 2,
    CHUNK_RSP = 3,
    NEIGHBOR_LEAVE = 4,
    LEAVING = 5
};

/**
 * Class generated from <tt>applications/denacastapp/VideoMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet VideoMessage
 * {
 *     int command enum(VideoCommand);
 *     TransportAddress dstNode;	
 * 	TransportAddress srcNode;	
 * 	double deadLine;			
 * 	Chunk chunk;			
 * 	VideoFrame VFrame;		
 * }
 * </pre>
 */
class VideoMessage : public ::cPacket
{
  protected:
    int command_var;
    ::TransportAddress dstNode_var;
    ::TransportAddress srcNode_var;
    double deadLine_var;
    ::Chunk chunk_var;
    ::VideoFrame VFrame_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VideoMessage&);

  public:
    VideoMessage(const char *name=NULL, int kind=0);
    VideoMessage(const VideoMessage& other);
    virtual ~VideoMessage();
    VideoMessage& operator=(const VideoMessage& other);
    virtual VideoMessage *dup() const {return new VideoMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getCommand() const;
    virtual void setCommand(int command_var);
    virtual TransportAddress& getDstNode();
    virtual const TransportAddress& getDstNode() const {return const_cast<VideoMessage*>(this)->getDstNode();}
    virtual void setDstNode(const TransportAddress& dstNode_var);
    virtual TransportAddress& getSrcNode();
    virtual const TransportAddress& getSrcNode() const {return const_cast<VideoMessage*>(this)->getSrcNode();}
    virtual void setSrcNode(const TransportAddress& srcNode_var);
    virtual double getDeadLine() const;
    virtual void setDeadLine(double deadLine_var);
    virtual Chunk& getChunk();
    virtual const Chunk& getChunk() const {return const_cast<VideoMessage*>(this)->getChunk();}
    virtual void setChunk(const Chunk& chunk_var);
    virtual VideoFrame& getVFrame();
    virtual const VideoFrame& getVFrame() const {return const_cast<VideoMessage*>(this)->getVFrame();}
    virtual void setVFrame(const VideoFrame& VFrame_var);
};

inline void doPacking(cCommBuffer *b, VideoMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, VideoMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/denacastapp/VideoMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet BufferMapMessage
 * {
 * 	TransportAddress srcNode;		
 *     double totalBandwidth;   
 *     double myHopCount;		
 *     BufferMap buffermap;	
 * }
 * </pre>
 */
class BufferMapMessage : public ::cPacket
{
  protected:
    ::TransportAddress srcNode_var;
    double totalBandwidth_var;
    double myHopCount_var;
    ::BufferMap buffermap_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BufferMapMessage&);

  public:
    BufferMapMessage(const char *name=NULL, int kind=0);
    BufferMapMessage(const BufferMapMessage& other);
    virtual ~BufferMapMessage();
    BufferMapMessage& operator=(const BufferMapMessage& other);
    virtual BufferMapMessage *dup() const {return new BufferMapMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual TransportAddress& getSrcNode();
    virtual const TransportAddress& getSrcNode() const {return const_cast<BufferMapMessage*>(this)->getSrcNode();}
    virtual void setSrcNode(const TransportAddress& srcNode_var);
    virtual double getTotalBandwidth() const;
    virtual void setTotalBandwidth(double totalBandwidth_var);
    virtual double getMyHopCount() const;
    virtual void setMyHopCount(double myHopCount_var);
    virtual BufferMap& getBuffermap();
    virtual const BufferMap& getBuffermap() const {return const_cast<BufferMapMessage*>(this)->getBuffermap();}
    virtual void setBuffermap(const BufferMap& buffermap_var);
};

inline void doPacking(cCommBuffer *b, BufferMapMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BufferMapMessage& obj) {obj.parsimUnpack(b);}


#endif // _VIDEOMESSAGE_M_H_
